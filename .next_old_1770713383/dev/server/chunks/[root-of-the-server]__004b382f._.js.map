{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Users/utkusakallioglu/Documents/nakis/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n\nexport default prisma;\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY;AAEhE,wCAA2C,gBAAgB,MAAM,GAAG;uCAErD"}},
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["file:///Users/utkusakallioglu/Documents/nakis/src/lib/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\";\nimport Credentials from \"next-auth/providers/credentials\";\nimport Google from \"next-auth/providers/google\";\nimport Apple from \"next-auth/providers/apple\";\nimport { PrismaAdapter } from \"@auth/prisma-adapter\";\nimport { compare } from \"bcryptjs\";\nimport prisma from \"@/lib/prisma\";\nimport type { Role } from \"@/types\";\n\ndeclare module \"next-auth\" {\n    interface Session {\n        user: {\n            id: string;\n            email: string;\n            name?: string | null;\n            image?: string | null;\n            role: Role;\n        };\n    }\n\n    interface User {\n        id: string;\n        email: string;\n        name?: string | null;\n        image?: string | null;\n        role: Role;\n    }\n}\n\ndeclare module \"@auth/core/jwt\" {\n    interface JWT {\n        id: string;\n        role: Role;\n        image?: string | null;\n        sessionVersion?: number;\n        invalidated?: boolean;\n    }\n}\n\nexport const { handlers, signIn, signOut, auth } = NextAuth({\n    adapter: PrismaAdapter(prisma) as any,\n    trustHost: process.env.AUTH_TRUST_HOST === 'true',\n    providers: [\n        Google({\n            clientId: process.env.GOOGLE_CLIENT_ID,\n            clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n            allowDangerousEmailAccountLinking: true,\n        }),\n        Credentials({\n            name: \"credentials\",\n            credentials: {\n                email: { label: \"Email\", type: \"email\" },\n                password: { label: \"Password\", type: \"password\" },\n            },\n            async authorize(credentials) {\n                if (!credentials?.email || !credentials?.password) {\n                    return null;\n                }\n\n                const user = await prisma.user.findUnique({\n                    where: {\n                        email: credentials.email as string,\n                    },\n                });\n\n                if (!user || user.password === null) {\n                    return null;\n                }\n\n                const isPasswordValid = await compare(\n                    credentials.password as string,\n                    user.password\n                );\n\n                if (!isPasswordValid) {\n                    return null;\n                }\n\n                return {\n                    id: user.id,\n                    email: user.email,\n                    name: user.name,\n                    image: user.image,\n                    role: user.role as Role,\n                };\n            },\n        }),\n    ],\n    callbacks: {\n        async jwt({ token, user, trigger, session }) {\n            const userId = (user?.id || token.id) as string | undefined;\n\n            if (userId) {\n                const dbUser = await prisma.user.findUnique({\n                    where: { id: userId },\n                    select: { sessionVersion: true },\n                });\n\n                if (!dbUser) {\n                    token.invalidated = true;\n                    token.exp = Math.floor(Date.now() / 1000) - 10;\n                    return token;\n                }\n\n                if (user) {\n                    token.sessionVersion = dbUser.sessionVersion;\n                    token.invalidated = false;\n                } else {\n                    const tokenSessionVersion = typeof token.sessionVersion === \"number\" ? token.sessionVersion : 0;\n                    if (tokenSessionVersion !== dbUser.sessionVersion) {\n                        token.invalidated = true;\n                        token.exp = Math.floor(Date.now() / 1000) - 10;\n                        return token;\n                    }\n                }\n            }\n\n            if (user) {\n                token.id = user.id;\n                token.role = (user as any).role || \"CUSTOMER\";\n                token.image = user.image;\n            }\n            if (trigger === \"update\" && session) {\n                if (session.role) token.role = session.role;\n                if (session.image !== undefined) token.image = session.image;\n                if (session.name !== undefined) token.name = session.name;\n            }\n            return token;\n        },\n        async session({ session, token }) {\n            if (token.invalidated) {\n                return { ...session, expires: new Date(0).toISOString() };\n            }\n\n            if (token && session.user) {\n                session.user.id = token.id as string;\n                session.user.role = token.role as Role;\n                session.user.image = token.image as string | null;\n                if (token.name) session.user.name = token.name as string;\n            }\n            return session;\n        },\n    },\n    events: {\n        async createUser({ user }) {\n            // New OAuth users: sync profile data and set CUSTOMER role\n            if (user.id) {\n                await prisma.user.update({\n                    where: { id: user.id },\n                    data: {\n                        role: \"CUSTOMER\",\n                        // Sync name and email from OAuth profile\n                        ...(user.name && { name: user.name }),\n                        ...(user.email && { email: user.email }),\n                        ...(user.image && { image: user.image }),\n                    }\n                });\n            }\n        }\n    },\n    pages: {\n        signIn: \"/login\",\n    },\n    session: {\n        strategy: \"jwt\",\n    },\n});\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 244, "column": 0}, "map": {"version":3,"sources":["file:///Users/utkusakallioglu/Documents/nakis/src/app/api/user/profile/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { auth } from \"@/lib/auth\";\nimport prisma from \"@/lib/prisma\";\nimport { z } from \"zod\";\n\nconst profileSchema = z.object({\n    language: z.enum([\"en\", \"tr\"]).optional(),\n    billingAddress: z.string().optional(),\n    image: z.string().optional(),\n    name: z.string().optional(),\n    email: z.string().email(\"Geçerli bir e-posta adresi girin\").optional(),\n});\n\nexport async function GET() {\n    try {\n        const session = await auth();\n        if (!session?.user) {\n            return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n        }\n\n        const user = await prisma.user.findUnique({\n            where: { id: session.user.id },\n            select: {\n                id: true,\n                email: true,\n                name: true,\n                role: true,\n                language: true,\n                billingAddress: true,\n                image: true,\n                pendingEmail: true,\n                pendingName: true,\n                emailVerificationToken: true\n            },\n        });\n\n        return NextResponse.json(user);\n    } catch (error) {\n        return NextResponse.json(\n            { error: \"Failed to fetch profile\" },\n            { status: 500 }\n        );\n    }\n}\n\nexport async function PATCH(request: Request) {\n    try {\n        const session = await auth();\n        if (!session?.user) {\n            return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n        }\n\n        const body = await request.json();\n        const validatedData = profileSchema.parse(body);\n\n        const currentProfile = await prisma.user.findUnique({\n            where: { id: session.user.id }\n        });\n\n        if (!currentProfile) {\n            return NextResponse.json({ error: \"User not found\" }, { status: 404 });\n        }\n\n        const updateData: any = {};\n        if (validatedData.language) updateData.language = validatedData.language;\n        if (validatedData.billingAddress !== undefined) updateData.billingAddress = validatedData.billingAddress;\n        if (validatedData.image !== undefined) updateData.image = validatedData.image;\n\n        // Check if name or email is changing\n        const isNameChanging = validatedData.name && validatedData.name !== currentProfile.name;\n        const isEmailChanging = validatedData.email && validatedData.email !== (currentProfile.pendingEmail || currentProfile.email);\n\n        if (isEmailChanging && validatedData.email) {\n            const existingUser = await prisma.user.findUnique({\n                where: { email: validatedData.email }\n            });\n            if (existingUser && existingUser.id !== session.user.id) {\n                return NextResponse.json(\n                    { error: \"Bu e-posta adresi zaten kullanımda\" },\n                    { status: 400 }\n                );\n            }\n        }\n\n        // Name changes are applied directly\n        if (isNameChanging && validatedData.name) {\n            updateData.name = validatedData.name;\n        }\n\n        // Email changes require verification\n        if (isEmailChanging) {\n            updateData.pendingEmail = validatedData.email || currentProfile.pendingEmail || currentProfile.email;\n            updateData.pendingName = validatedData.name || currentProfile.name;\n            updateData.emailVerificationToken = crypto.randomUUID();\n            updateData.emailVerificationTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24 hours\n\n            // TODO: Send verification email to validatedData.email || currentProfile.email\n        }\n\n        const updatedUser = await prisma.user.update({\n            where: { id: session.user.id },\n            data: updateData,\n        });\n\n        return NextResponse.json(updatedUser);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            return NextResponse.json(\n                { error: error.issues[0].message },\n                { status: 400 }\n            );\n        }\n        return NextResponse.json(\n            { error: \"Profil güncellenirken hata oluştu\" },\n            { status: 500 }\n        );\n    }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,gBAAgB,0MAAC,CAAC,MAAM,CAAC;IAC3B,UAAU,0MAAC,CAAC,IAAI,CAAC;QAAC;QAAM;KAAK,EAAE,QAAQ;IACvC,gBAAgB,0MAAC,CAAC,MAAM,GAAG,QAAQ;IACnC,OAAO,0MAAC,CAAC,MAAM,GAAG,QAAQ;IAC1B,MAAM,0MAAC,CAAC,MAAM,GAAG,QAAQ;IACzB,OAAO,0MAAC,CAAC,MAAM,GAAG,KAAK,CAAC,oCAAoC,QAAQ;AACxE;AAEO,eAAe;IAClB,IAAI;QACA,MAAM,UAAU,MAAM,IAAA,kJAAI;QAC1B,IAAI,CAAC,SAAS,MAAM;YAChB,OAAO,sKAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACtE;QAEA,MAAM,OAAO,MAAM,uJAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YACtC,OAAO;gBAAE,IAAI,QAAQ,IAAI,CAAC,EAAE;YAAC;YAC7B,QAAQ;gBACJ,IAAI;gBACJ,OAAO;gBACP,MAAM;gBACN,MAAM;gBACN,UAAU;gBACV,gBAAgB;gBAChB,OAAO;gBACP,cAAc;gBACd,aAAa;gBACb,wBAAwB;YAC5B;QACJ;QAEA,OAAO,sKAAY,CAAC,IAAI,CAAC;IAC7B,EAAE,OAAO,OAAO;QACZ,OAAO,sKAAY,CAAC,IAAI,CACpB;YAAE,OAAO;QAA0B,GACnC;YAAE,QAAQ;QAAI;IAEtB;AACJ;AAEO,eAAe,MAAM,OAAgB;IACxC,IAAI;QACA,MAAM,UAAU,MAAM,IAAA,kJAAI;QAC1B,IAAI,CAAC,SAAS,MAAM;YAChB,OAAO,sKAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACtE;QAEA,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,gBAAgB,cAAc,KAAK,CAAC;QAE1C,MAAM,iBAAiB,MAAM,uJAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YAChD,OAAO;gBAAE,IAAI,QAAQ,IAAI,CAAC,EAAE;YAAC;QACjC;QAEA,IAAI,CAAC,gBAAgB;YACjB,OAAO,sKAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAiB,GAAG;gBAAE,QAAQ;YAAI;QACxE;QAEA,MAAM,aAAkB,CAAC;QACzB,IAAI,cAAc,QAAQ,EAAE,WAAW,QAAQ,GAAG,cAAc,QAAQ;QACxE,IAAI,cAAc,cAAc,KAAK,WAAW,WAAW,cAAc,GAAG,cAAc,cAAc;QACxG,IAAI,cAAc,KAAK,KAAK,WAAW,WAAW,KAAK,GAAG,cAAc,KAAK;QAE7E,qCAAqC;QACrC,MAAM,iBAAiB,cAAc,IAAI,IAAI,cAAc,IAAI,KAAK,eAAe,IAAI;QACvF,MAAM,kBAAkB,cAAc,KAAK,IAAI,cAAc,KAAK,KAAK,CAAC,eAAe,YAAY,IAAI,eAAe,KAAK;QAE3H,IAAI,mBAAmB,cAAc,KAAK,EAAE;YACxC,MAAM,eAAe,MAAM,uJAAM,CAAC,IAAI,CAAC,UAAU,CAAC;gBAC9C,OAAO;oBAAE,OAAO,cAAc,KAAK;gBAAC;YACxC;YACA,IAAI,gBAAgB,aAAa,EAAE,KAAK,QAAQ,IAAI,CAAC,EAAE,EAAE;gBACrD,OAAO,sKAAY,CAAC,IAAI,CACpB;oBAAE,OAAO;gBAAqC,GAC9C;oBAAE,QAAQ;gBAAI;YAEtB;QACJ;QAEA,oCAAoC;QACpC,IAAI,kBAAkB,cAAc,IAAI,EAAE;YACtC,WAAW,IAAI,GAAG,cAAc,IAAI;QACxC;QAEA,qCAAqC;QACrC,IAAI,iBAAiB;YACjB,WAAW,YAAY,GAAG,cAAc,KAAK,IAAI,eAAe,YAAY,IAAI,eAAe,KAAK;YACpG,WAAW,WAAW,GAAG,cAAc,IAAI,IAAI,eAAe,IAAI;YAClE,WAAW,sBAAsB,GAAG,OAAO,UAAU;YACrD,WAAW,6BAA6B,GAAG,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,OAAO,WAAW;QAElG,+EAA+E;QACnF;QAEA,MAAM,cAAc,MAAM,uJAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YACzC,OAAO;gBAAE,IAAI,QAAQ,IAAI,CAAC,EAAE;YAAC;YAC7B,MAAM;QACV;QAEA,OAAO,sKAAY,CAAC,IAAI,CAAC;IAC7B,EAAE,OAAO,OAAO;QACZ,IAAI,iBAAiB,0MAAC,CAAC,QAAQ,EAAE;YAC7B,OAAO,sKAAY,CAAC,IAAI,CACpB;gBAAE,OAAO,MAAM,MAAM,CAAC,EAAE,CAAC,OAAO;YAAC,GACjC;gBAAE,QAAQ;YAAI;QAEtB;QACA,OAAO,sKAAY,CAAC,IAAI,CACpB;YAAE,OAAO;QAAoC,GAC7C;YAAE,QAAQ;QAAI;IAEtB;AACJ"}}]
}